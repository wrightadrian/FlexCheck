using System;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Xml.XPath;

namespace lib {
    public class Xpath {
        private const String BR = "<br>";
        private const String LT = "&lt;";
        private const String GT = "&gt;";
        private const String NBSP = "&nbsp;";
        private const String FMT_SPAN_WITH_TITLE = "<span class=\"{0}\" title=\"{1}\">";
        private const String FMT_SPAN_NO_TITLE = "<span class=\"{0}\">";
        private const String FMT_NAMEDANCHOR = "<a name=\"{0}\"/></a>";

        //public const String ROOT_MATCH_NAME = "match";
        /// <summary>
        /// Controls the embedding of named HTML anchors in the HTML generated by Match()
        /// </summary>
        public bool UseAnchors { get; set; }
        /// <summary>
        /// Controls the generation of tool tips in the HTML generated by Match()
        /// </summary>
        public bool UseToolTips { get; set; }

        //public int MatchCount { get; private set; }

        public string Match(XmlDocument xdoc, List<XpathExpressionInfo> lstXei) {

            XPathNavigator xpnav = xdoc.CreateNavigator();
            StringBuilder sb = new StringBuilder(2048);

            traverseNodes(xpnav.SelectChildren(XPathNodeType.All), lstXei, sb, 0 /* indent level */);

            return sb.ToString();
        }

        private void traverseNodes(  XPathNodeIterator nodeSet,
                                            List<XpathExpressionInfo> lstXei,
                                            StringBuilder sb,
                                            int indentLevel) {

            StringBuilder sbid = new StringBuilder(NBSP.Length * indentLevel);
            for (int i = 0; i < indentLevel; i++) {
                sbid.Append(NBSP);
            }
            string indent = sbid.ToString();
            XpathExpressionInfo matchForElement;
            XpathExpressionInfo matchForAttr;
            bool matchesElement = false;
            bool matchesAttr = false;

            while (nodeSet.MoveNext()) {
                var node = nodeSet.Current;

                switch (node.NodeType) {
                    case XPathNodeType.Attribute:
                        break;
                    case XPathNodeType.Comment:
                        // ignore
                        break;
                    case XPathNodeType.Element:
                        matchesElement = NodeMatches(node, lstXei, out matchForElement);
                        if (matchesElement) {
                            if (UseAnchors)
                                sb.AppendFormat(FMT_NAMEDANCHOR, matchForElement.RootAnchorName + matchForElement.NumMatches++);
                            if (UseToolTips)
                                sb.AppendFormat(FMT_SPAN_WITH_TITLE, matchForElement.CssClassSelector, matchForElement.XpathExpression);
                            else
                                sb.AppendFormat(FMT_SPAN_NO_TITLE, matchForElement.CssClassSelector);
                        }
                        sb.AppendFormat("{0}{1}{2} ", indent, LT, node.Name); // starting tag

                        // process any namespaces
                        bool hasNamespace = node.MoveToFirstNamespace(XPathNamespaceScope.Local);
                        if (hasNamespace) {
                            do {
                                if (string.IsNullOrEmpty(node.Name))
                                    // default namespace . . .
                                    sb.AppendFormat("xmlns=\"{0}\" ", node.Value);
                                else
                                    sb.AppendFormat("xmlns:{0}=\"{1}\" ", node.Name, node.Value);
                            } while (node.MoveToNextNamespace(XPathNamespaceScope.Local));
                            node.MoveToParent();
                        }

                        // process attributes
                        if (node.HasAttributes) {
                            node.MoveToFirstAttribute();
                            do {
                                matchesAttr = NodeMatches(node, lstXei, out matchForAttr);
                                if (matchesAttr) {
                                    if (UseAnchors)
                                        sb.AppendFormat(FMT_NAMEDANCHOR, matchForAttr.RootAnchorName + matchForAttr.NumMatches++);
                                    if (UseToolTips)
                                        sb.AppendFormat(FMT_SPAN_WITH_TITLE, matchForAttr.CssClassSelector, matchForAttr.XpathExpression);
                                    else
                                        sb.AppendFormat(FMT_SPAN_NO_TITLE, matchForAttr.CssClassSelector);
                                    sb.AppendFormat("{0}=\"{1}\"</span> ", node.Name, node.Value);
                                }
                                else 
                                    sb.AppendFormat("{0}=\"{1}\" ", node.Name, node.Value);
                            } while (node.MoveToNextAttribute());
                            node.MoveToParent();
                        } // if (node.HasAttributes)
                        sb.Length--; // trim the trailing space

                        if (node.HasChildren) {
                            sb.AppendFormat(">{0}", BR);
                            traverseNodes(node.SelectChildren(XPathNodeType.Element), lstXei, sb, indentLevel+3); // recursion
                            sb.AppendFormat("{0}{1}/{2}>", indent, LT, node.Name); // closing tag
                        }
                        else
                            sb.Append("/>");
                        if (matchesElement) {
                            sb.Append("</span>");
                        }
                        sb.Append(BR);
                        break;
                    case XPathNodeType.Namespace:
                        break;
                    case XPathNodeType.ProcessingInstruction:
                        break;
                    case XPathNodeType.Root:
                        break;
                    case XPathNodeType.SignificantWhitespace:
                        break;
                    case XPathNodeType.Text:
                        break;
                    case XPathNodeType.Whitespace:
                        break;
                    default:
                        break;
                }
            } // while (nodeSet.MoveNext()) {
        }

        private static bool NodeMatches(    XPathNavigator node,
                                            List<XpathExpressionInfo> lstXei,
                                            out XpathExpressionInfo theMatch) {
            foreach (var xei in lstXei) {
                if (node.Matches(xei.CompiledExpression)) {
                    theMatch = xei;
                    return true; // found a match :-)
                }
            }
            theMatch = null;
            return false; // no match found :-(
        }
    }
}
